drop procedure if exists insereFila;
drop procedure if exists recursivo;

delimiter &&

-- recebe o elemento a ser criado e retorna o id real dele no banco
create procedure recursivo (IN prox_ int, OUT nProx int)
begin
	declare atualProx int default null; 
    declare atualAlt int default null;
    declare atualTemp int;
    declare atualEtapa int;
    declare atualResp int;

	-- pega o tempId do elemento desejado e salva seus prox e alternativo
	select prox, alternativo, template, etapa, responsavel into atualProx, atualAlt, atualTemp, atualEtapa, atualResp
		from ffilas where tempId = prox_;
    
    -- se o elemento atual tem proximo, entra na recursão e substitui o tempId usado no campo prox pelo id real do próximo criado no banco
    if(atualProx is not null) then
		call recursivo(atualProx, @nAtualProx);
        set atualProx = @nAtualProx;
	end if;
    
    -- se o elemento atual tem alternativo, entra na recursão e substirui o tempId usado no campo alternativo pelo id real do alt criado no banco
    if(atualAlt is not null) then
		call recursivo(atualAlt, @nAtualAlt);
        set atualAlt = @nAtualAlt;
	end if;
    
    -- depois de susbstituir os ids temporarios (se existirem) pelos reais, cria o elemento
    insert into Etapa_Relacao(proximo, alternativo, template, etapa, responsavel) values (atualProx, atualAlt, atualTemp, atualEtapa, atualResp);

	-- retorna o id do ultimo elemento criado (ou seja, esse)
    select etapa_relacao_id from Etapa_Relacao er
    where etapa_relacao_id = last_insert_id() and (er.proximo = atualProx or (er.proximo is null and atualProx is null)) and (er.alternativo = atualAlt or(er.alternativo is null and atualAlt is null)) and er.template = atualTemp and er.etapa = atualEtapa and er.responsavel = atualResp
    into nProx;

    if(nProx is null) then
		signal sqlstate '45000';
	end if;
end&&

create procedure insereFila(IN json_in json)
BEGIN
    declare primeiroProx integer default null;
    declare primeiroAlt integer default null;
    declare primeiroTemplate integer;
    declare primeiroEtapa integer;
    declare primeiroResp integer;
    
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
        BEGIN
            -- Rollback if any SQL exception occurs
            ROLLBACK;
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Erro de inserção.';
        END;

    
    drop temporary table if exists ffilas;

	start transaction;
    -- cria uma tabela temporária a partir do json recebido
    create temporary table ffilas as
    select
		tempId,
        prox,
        alternativo,
        template,
        etapa,
        responsavel
	from
		json_table(
			@json_data,
            '$[*]' columns (
				tempId int path '$.tempId',
				prox int path '$.prox',
                alternativo int path '$.alternativo',
                template int path '$.template',
                etapa int path '$.etapa',
                responsavel int path '$.responsavel'
			)
		) as ff;
    
    -- seleciona o próximo do primeiro elemento; o elemento inicial PRECISA ter tempId = 1;
	select prox, alternativo, template, etapa, responsavel into primeiroProx, primeiroAlt, primeiroTemplate, primeiroEtapa, primeiroResp
		from ffilas where tempId = 1;
    
    -- se o primeiro elemento tiver um próximo, inicia a recursão e substitui o valor temporário pelo real
    if(primeiroProx is not null) then
		call recursivo(primeiroProx, @nProx);
		set primeiroProx = @nProx;
	end if;
    
    
    -- se o primeiro elemento tiver um alternativo, inicia a recursão e substitui o valor temporário pelo real
    if(primeiroAlt is not null) then
		call recursivo(primeiroAlt, @nAlt);
        set primeiroAlt = @nAlt;
	end if;
    
    -- após ter criado todos os próximos e alternativos, cria o elemento inicial
    insert into Etapa_Relacao(proximo, alternativo, template, etapa, responsavel) values (primeiroProx, primeiroAlt, primeiroTemplate, primeiroEtapa, primeiroResp);

	-- destroi a tabela temporária
    drop temporary table ffilas;
    commit;

end&&
delimiter ;

